# OthelloCoursework
Othello coursework code,readme and .doc

<H1> AI Algorithm </H1>


The algorithm for the ai to determin is made up of primarily 2 functions. The first of which is called ai move and the second called simulate_placement

<H2>ai_move</H2>

![ai_move](https://github.com/user-attachments/assets/37624769-1e51-4f3f-8be5-d87dc894ac9e)

The function takes in one argument which is the number of moves left. First a list called potential_moves is created and this will be used to store all the moves that the ai could make on its turn aswell as the strengtth of each move. Then the program attempts to iterate through every cell in the board. This is done by a nested for loop as the board is a 2d array of rows and columns. If an exception is hit then the exception is logged and the move (-1,-1) is returned. This is impossible to get from the board as tthe indeces of the list cant be negative so therefore the move function knows the ai cant make a move and it can handle it appropriately. If an exception is not hit it checks if it would be a legal move for the ai to place a light counter on that square by calling the function legal_move. If it is a legal move a copy of the board is created. The reason a copy of the board is created is because the ai simulates the moevs it could make for the next 3 turns, and we dont want to alter the actual game board whilst trying out moves. Then the counter is placed at the coordinates on the copy board, and the counters that need to be flipped are got using the function get_cells_to_convert. Then the function flips all the cells that need to be flipped and gets the number of counters that have been flipped to light as a result of the move. This serves like a score for the move as the more flips the better the move. After that, the ai simulates the next 2 turns which would be the next player and ai turn using simulate_placement. This simulates both players playing 1 optimal move each and returns the overall number of light counters gained. This is done so the ai can pick a better move for tthe long term game rather than justt the current move. This score is then added to the number of counters flipped by making the move and the co-ordinates of the move and its score are added to the potential_moves list. Once all the cells have been evaluated, the program chooses the best move by selecting the move with tthe highest score and returns the co-ordinates of the move. 

<H2>simulate_placement</H2>

![simulate_placement](https://github.com/user-attachments/assets/d442451d-f065-4b03-b075-5687b814c00d)

simulate_placement is a function used to perform a depth first search of the best move for the ai to make, assuming both players play optimal moves. simulate_placement takes 4 argumennts being temporaryboard which is the board to simulate the move on, currentdepth which is how many moves in the future the evaluation is taking place. Third is the colour of the piece that the move is simulating and finally maxdepth is the maximum number of moves to look ahead. First the function checks if it has reached the maximum depth and if it has it returns a score of 0 as no move is simulated. Next it sets score to 0 and checks to see if the colour of the counter being played is light. If it is it sets the best score to -9999 but if its dark it sets the best score to 9999. This is because light wants to choose the score thats got the highest number of flips, whereas dark wants to play a move that minimises the number of flips light can make so chooses the move with the smallest score. By setting the values to 9999/-9999 this always ensures the first move selected is better/worse and always counted as the starting best move. Then the function uses a double for loop to iterate through the board and check if playing a counter of the players colour in the cell is valid. If the move is valid the move is executed on a copy off the temporary board. The reason a copy is made is so that different tests at the same move depth ahead dont influence eachother by beingg placed on the same board object, which would mean each test is conducted on a different board. The cells to flip because of the move are then gathered using get_cells_to_convert() and flipped. Then the counter colour is flipped so that the next turn can be simulated by calling simulate_placement recursively with the board being a board with the current depth move made on it, the current depth being currentdepth + 1 and the colour of piece being tthe next players colour. 

After the recursive function call there is a block of code to add the scores of the moves. This will trigger once the simulate_placement function hits the maximum depth and returns. If it was the light players turn, it adds the number of flips it gets from the moves and compares it to the best score currently for tthe move being tested at the current depth. If the score is higher than the best then it becomes the new best as the move has higher value. If its darks turn the number of flips is subtracted from the score as dark gaining counters is bad for the ai light player.The dark player wants to play a move that minimises lights advantage so the best move for dark is the move that gives the light player the lowest score. Once all the moves have been simulated for the current depth tthe best that a move at tthat depth could get is returned. 




