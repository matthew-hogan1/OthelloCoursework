# OthelloCoursework
Othello coursework code,readme and .doc

<H1> AI Algorithm </H1>


The algorithm for the ai to determin is made up of primarily 2 functions. The first of which is called ai move and the second called simulate_placement

<H2>ai_move()</H2>

![ai_move](https://github.com/user-attachments/assets/37624769-1e51-4f3f-8be5-d87dc894ac9e)

The function takes in one argument which is the number of moves left. First a list called potential_moves is created and this will be used to store all the moves that the ai could make on its turn aswell as the strengtth of each move. Then the program attempts to iterate through every cell in the board. This is done by a nested for loop as the board is a 2d array of rows and columns. If an exception is hit then the exception is logged and the move (-1,-1) is returned. This is impossible to get from the board as tthe indeces of the list cant be negative so therefore the move function knows the ai cant make a move and it can handle it appropriately. If an exception is not hit it checks if it would be a legal move for the ai to place a light counter on that square by calling the function legal_move. If it is a legal move a copy of the board is created. The reason a copy of the board is created is because the ai simulates the moevs it could make for the next 3 turns, and we dont want to alter the actual game board whilst trying out moves. Then the counter is placed at the coordinates on the copy board, and the counters that need to be flipped are got using the function get_cells_to_convert. Then the function flips all the cells that need to be flipped and gets the number of counters that have been flipped to light as a result of the move. This serves like a score for the move as the more flips the better the move. After that, the ai simulates the next 2 turns which would be the next player and ai turn using simulate_placement. This simulates both players playing 1 optimal move each and returns the overall number of light counters gained. This is done so the ai can pick a better move for tthe long term game rather than justt the current move. This score is then added to the number of counters flipped by making the move and the co-ordinates of the move and its score are added to the potential_moves list. Once all the cells have been evaluated, the program chooses the best move by selecting the move with tthe highest score and returns the co-ordinates of the move. 

<H2>simulate_placement()</H2>

![simulate_placement](https://github.com/user-attachments/assets/d442451d-f065-4b03-b075-5687b814c00d)

simulate_placement is a function used to perform a depth first search of the best move for the ai to make, assuming both players play optimal moves. simulate_placement takes 4 argumennts being temporaryboard which is the board to simulate the move on, currentdepth which is how many moves in the future the evaluation is taking place. Third is the colour of the piece that the move is simulating and finally maxdepth is the maximum number of moves to look ahead. First the function checks if it has reached the maximum depth and if it has it returns a score of 0 as no move is simulated. Next it sets score to 0 and checks to see if the colour of the counter being played is light. If it is it sets the best score to -9999 but if its dark it sets the best score to 9999. This is because light wants to choose the score thats got the highest number of flips, whereas dark wants to play a move that minimises the number of flips light can make so chooses the move with the smallest score. By setting the values to 9999/-9999 this always ensures the first move selected is better/worse and always counted as the starting best move. Then the function uses a double for loop to iterate through the board and check if playing a counter of the players colour in the cell is valid. If the move is valid the move is executed on a copy off the temporary board. The reason a copy is made is so that different tests at the same move depth ahead dont influence eachother by beingg placed on the same board object, which would mean each test is conducted on a different board. The cells to flip because of the move are then gathered using get_cells_to_convert() and flipped. Then the counter colour is flipped so that the next turn can be simulated by calling simulate_placement recursively with the board being a board with the current depth move made on it, the current depth being currentdepth + 1 and the colour of piece being tthe next players colour. 

After the recursive function call there is a block of code to add the scores of the moves. This will trigger once the simulate_placement function hits the maximum depth and returns. If it was the light players turn, it adds the number of flips it gets from the moves and compares it to the best score currently for tthe move being tested at the current depth. If the score is higher than the best then it becomes the new best as the move has higher value. If its darks turn the number of flips is subtracted from the score as dark gaining counters is bad for the ai light player.The dark player wants to play a move that minimises lights advantage so the best move for dark is the move that gives the light player the lowest score. Once all the moves have been simulated for the current depth tthe best that a move at tthat depth could get is returned. 

<H1>flask_game_engine.py</H1>

flask_game_engine.py is where the flask responses for the gui is handled aswell as the simulation for the ai moves. First a logger is initialised so an event and error log can be displayed in the console whilst the program is running. Next the flask app is initialised. Next a class called GameEngine is defined and this is used to store the global game state. This includes the board which is created using initialise_board(), self.players which is a list containing 2 instances of the player class, one for the dark player and one for the light. self.player_turns is set to 2 initially and this is used to keep track of which players turn it is. This is done by taking player_turn and performing the mod of 2 on it. This always gives a value of 0 or 1 which corresponds to the index of the player whos turn it is in the self.players list. Finally the move_counter is set to 60 and used to keep track of when all possible moves cells have been filled. The GameEngine is then initialised under tthe variable name engine. 

<H2>get_cells_to_convert()</H2>

![get_cells_to_convert](https://github.com/user-attachments/assets/ccbec199-60b1-464e-87c8-3e31b03ed3ce)


The function get_cells_to_convert is used to get a list of all the different counters that are framed by opponant counters as a result of a given move, meaning they have to be flipped colour. First, all the subsections of the board where counters may be framed are gathered using the get_subsect_of_board(). This is because there are 8 different directions that need to be checked, which match up to the directions on a compass. Next teh subsections are iterated through to get a complete list of all the cells that are framed in all directions. For each subsection the values of the cells are got using .get_board_values() on the subsection and the co-ordinates of the cells in the subsection are got using .get_board_indices(). Then each cell in the subsection is checked by enumerating through the list of colours which stores the cell values. If it is the first cell in the subsection then it it skipped as it is the counter that has just been placed. If the cell is empty this breaks the iteration of the subsection as it breaks the chain of counters that could be framed. If the cell contains a counter thats the same colour as the counter being placed the loop also breaks as this forms the end counter in the framing of tthe opponants counters. If neither of these conditions were hit then the cell must contain an opponants counter. A list is then formed of the counters in the subsection that still have to be checked. This is in order to check if the current cell is actually framed by an another opponants counter or not.First the index of the nearest empty cell is recorded, and if there isnt an empty cell in the subsection the index is set to 9999. This is so that if there is another counter of the current players colour in the subsection it always counts as framing the pieces. Next the index of the closest counter of the players colour in the subsection is found. If there isnt another counter of the players colour in the subsection then the index is set to 10000. This is because in order for an opponants counter to be counted as a framed piece, there must be a piece of the current players colour further than it in the subsection which is checked by if currentcolour in remaining_positions_ahead, and also this piece must be part of an unbroken chain of counters i.e not with an empty cell in between. TThis is validated by checking that the index of the player counter is less than the closest empty cell. If there are neither an empty cell nor another counter to frame the opponants cell, the comparison would be 10000 < 9999 which returns false thus correctly identifying it as an invalid piece to be framed. If teh piece is framed then its coordinates are added to the list of cells to convert. Once all subsections have been iterated through it returns the list of cells to convert.

<H2>index()</H2>

This is the default flask route and renders the index.html template which provides the user the interactive board to play the game with, aswell as the save and load game controls. 

<H2>move()</H2>

![move](https://github.com/user-attachments/assets/2b1038a0-b146-42d9-bbc0-283bb62651ad)

Move is a function that servs as the flask route that allows the user to make their move. It is accessed by the route /move and expects 2 arguments x and y which correspond to the x and y coordinates where the user wants to place the counter. First the function gets which players turn it is by taking the modulous of 2 of the player_turn and setting the currentplayer to the player at that index in engine.players. The colour of that players counters is gotten by calling get_colour() on the currentplayer. If the current player is the dark player this means they are the human player and the x and y co-ordinates are retrieved from the html request. These are then converted to row and column indices by subtracting 1 as the python lists that represent the board are indexed at 0 whereas the html board starts at 1,1. If the x and y coordinates couldnt be retrieved from the request a response is returned with the status set to fail and the message saying "Could not get x and y coordinates". If the co-ordinates were retrieved succesfully, the move is checked to see if it is legal. If it is not a legal move a response is returned with the status fail and the message telling teh user the move is invalid. If the move is valid, the list of cells that need to be flipped due to the move is gotten using the function get_cells_to_convert. The players counter is then places at the coordinates they wanted and the necessary counters are flipped to the players colour of dark. Next it is the ai light players turn so the player turn is incremented by 1 and the move counter decreased by 1 since the human player just made a succesful move. The currentplayer and currentcolour are then updated to be the ai light player. First, the function checks if the move counter is 0. If it is this means the ai has nowhere to place its counter. If this happens the function skips the ai turn logic and enters the logic for when engine.move_counter = 0. Within this logic, the function iterates through the board and checks tthe contents of each cell. If it contains a light counter then the lightcount is incremented by 1 and if its a dark counter the darkcount is incremented by one. If the cell is empty neither counter is incremented. If the number of light counters is greatedr than the number of dark then the win message is set to be light wins. If dark has more counters than light then dark wins and if they ahve the same number then the win message is set to be a draw. Next the global game states within the engine are reset to their default values in order to start a new game. The function then provides a response to the gui with the finished key, which contains the message that the game finished as the move counter hit 0, the number of each counter on the board aswell as who won. The new fresh board is also provided in the response to start the new game. 

If the number of moves left afterr the userr makes their move was greater than 0, the ai gets to make their move. First the function ai_move is called. This is to retrieve the co-ordinates for the optimal move for the ai to make. If the move coordinates returned is (-1,-1) this means that the ai does not have a valid move that could be made and the ai's turn is skipped. If a valid coordinate was returned then the move is played and the dark cells that are flipped because of the move are gotten using get_cells_to_convert and flipped. The move counter is then decreased by 1 as a succesful move was made. Next a while loop is created and this loops until the dark player has a valid move to make. Whilst waiting for this outcome the ai will keep playing moves until either dark has a valid move, the ai runs out of moves or the ai and player both have no valid moves and the game finishes. First, both players have their can_move attribute set to FALSE at the start of each iteration by using the set_can_move method. Then the loop checks if tthe number of moves left is 0 and if it is the loop breaks and the moves_left = 0 logic is run. Then a nested for loop is used to iterate through the board and for each cell a check is performed to see if either light or dark could play a valid move. If they can play a legal move,the player objects respective can_move attribute is set to True and the board loop is broken. After iteratingg through all cells on the board, the function checks to see if the dark player has a legal move available to them. If they do then the engine.player_turn is incremented by 1 to swap to the dark players turn and the loop is broken. If they cannot move the function then checks if the ai player has a move available. If it does then the ai move logic is run and the ai takes a turn instead of the player. Then the move counter is decremented by 1 and the loop restarts. Finally if neither player has a legal move available to them then the pieces are summed and the winner determined by which player has the most counters. Then the engine game state attributes are restet to their default settings and a response is provided containing a finished key and the finished messsage, aswell as the new board to start the new game with. 

If the ai movement loop is broken because the dark player has a legal move and there are also stil moves left, then the function provides a response with the status success,aswell as the current state of the board and the player whos turn it is which will be dark. This allows the user to see what moves the ai made aswell as input their next move

<H2>save()</H2>

![save](https://github.com/user-attachments/assets/dd6e632c-5ccb-43c0-a62c-1808843c188c)

save is a function and also the flask route to allow the user to save their game to a json file. The route is accessed through /save and is the post method. This is because the filename that the user wants to save the game as needs to be sent. The filename should be sent as plaintext using the post method. The function attempts to decode the filename from the body of the request, however if an exception arises then a response is sent back with teh status fail and the message "Failed to retrieve the filename to save" to alert the user the game hasnt been saved. If the filename was decoded then the engine game states of the current board,player turn,moves left and if each player can move are stored in a dictionary. This is because they will be written to a json file with the name of the user entry using json.dump. A response is then provided with the status being success and the message alerting the user the game has been saved. If an exception was raised a fail response is provided to alert the user the save failed. 

<H2>load()</H2>

![Load](https://github.com/user-attachments/assets/87924bad-832b-45c2-85a5-584622b81ba5)

load is a function and also a flask route that allows the user to load a game they have previously saved. The route is accessed through /load and is also of the post method. The filename of the game that the user wants to load should be provided as plaintext in the body of the request. First tthe function decodes the filename. If this fails and exception is raised a response with status fail is provided witth the message "message": "An error occured when attempting to retrieve the filename to load.". If the filename was retrieved succesfully then the function attempts to find the json file in the ccurrent directory. If a game could not be found with the filename provided a response witth status fail is sent with the message telling the user that no saved game with the filename provided could be found. If the game was found, the json file is loaded using json.load(). The game engine states are then set to the values within the json file. A success response is then returned. This contains the new loaded board,which players turn it is and also a message to tell the user the game loaded succesfully. If an exception was raised such as the data beingg corrupted, a fail response is returned.


<H1>componants.py</H1>

componants.py is a file that has helper functions within it that are used by both the command line and flask versions of the game. Below are the functions used by the final flask version of the game. First a class called BoardSubsection is defined. BoardSubsection has 2 arguments values and indices. Values is a list of the contents of the cells in the board subsection. indices is a list of the co-ordinates contained within the subsection. The class has 2 methods the first is get_board_values(), which returns the list of the cell contents. The second is get_board_indices() which returns the list of coordinates of cells within the subsection. 

<H2>initialise_board()</H2>

![Initialise board](https://github.com/user-attachments/assets/14c5d223-e1a2-482b-9b11-73d3ed3013ab)


initialise_board is a function to create the game board, and it takes one argument which is size. This defaults to 8 and dictates how many rows and columns the board has. First a list called base_board is created and this will be used to store the row lists in. Then the function iterates size many times to create the correct number of rows. Within each iteration another nested for loop is performed size times. This creates the contents of tthe columns within the row. All cells are initially set to None so they are empty. Once a row has the correct number of columns it is appended to the base_boarrd and the next row is created. Once all rows have been created, the middle 4 cells in tthe board have their values set to counters. The top left and bottom rigght counter in the middle are set to Light and then the top right and bottom left cells of the middle are set to Dark counters. Finally the base_board is returned.

<H2>get_subsect_of_board()</H2>

![get subsect of board](https://github.com/user-attachments/assets/aebff08d-1fda-409b-b15e-8fbeaef22284)

get_subsect_of_board is used to get the list of cells that are in one of the directions from a given starting cell to the edge of the board. The function takes 4 arguments. The first is row_step which is how much should be added to the row index. A value of -1 would mean the cells are 'above' the starting row,0 means they are in the same row and 1 mean the cells are 'below' the starting cell. column_step is similar and dictates which columns should be added to the subsection. -1 means the columnss to the left of the start cell,0 is in the same column and 1 is columns to the right of the cell. The final 2 argumennts are current_row and current_column which is the cell where the counter is being placed. First a list called list_of_colours is created which will store the contents of the cells in the subsection. Next the list of board indices is created and is used to store the coordinates of the cells in the subsection. The index of the cell is the same in both lists making it easy to equate the coordinates to its contents. Next the board size is gotten using len(board) which gets the number of row lists which is the size. This forms the upper bound for the while loop. Whilst both the current row and current column being checked are between the bounds of >=0 and < board size, the function adds the contents of tthe cell art current row and column to the list of colours and the coordinates to listt of board indices. Then the current row and column are changed by the amount specified in row_step and row_column. Once the edge of the board has been hit the while loop ends and a BoardSubsection object is created with the list of colourts and list of board indices as arguments, before being returned. 

<H2>legal_move()</H2>

![legal move](https://github.com/user-attachments/assets/e9446a11-e0b8-4957-8c94-c0d83d25bca8)

legal_move is a function to determine if a given move follows the conditions of a legal othello move. The function takes 3 arguments. The first argument is playercolour, which is the colour of the counter being placed. Second is the coordinates of the move and finally the current board is passed into the function. First the function checks if there is already a counter placed in the cell, and if there is the function returns false to indicate the move isnt valid. Next, the function gets all 8 subsections of the board from the given cell and iterates through them. When iterating through them, whenever a cell with the same colour as the one being played is hit, the function checks if any cells have been added to the list list_of_cells_to_convert. If this is not empty then at least one opponant counter is framed by this move, which is th eminimum number needed for the move to be considered legal, and the function returns true. I this condition is never hit then that means no opponant counters are framed so the move is not legal, and the function returns False
